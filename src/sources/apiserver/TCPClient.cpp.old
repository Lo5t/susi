#include "apiserver/TCPClient.h"
#include <event2/thread.h>
#include <iostream>
#include <stdexcept>

Susi::Api::TCPClient::TCPClient(std::string host, unsigned short port) {
	
	initLibEvent();

	base = event_base_new();
	if (evthread_make_base_notifiable(base)<0) {
		throw std::runtime_error{"Couldn't make base notifiable!"};
	}

	bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE|BEV_OPT_THREADSAFE);

	ev_user = event_new(base, -1, EV_TIMEOUT|EV_READ, [](evutil_socket_t, short events, void *user_data){
		TCPClient * self = (TCPClient*)user_data;
		std::lock_guard<std::mutex> lock{self->mutex};
		struct event_base *base = self->base;
		auto fd = bufferevent_getfd(self->bev);
		evutil_closesocket(fd);
		event_base_loopbreak(base);
	}, this);

	auto eventcb = [](struct bufferevent *bev, short events, void *ctx){
		TCPClient * client = (TCPClient*)ctx;
		std::lock_guard<std::mutex> lock{client->mutex};
		if (events & BEV_EVENT_CONNECTED) {
			client->onConnect();
		} else if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
			struct event_base *base = client->base;
			if (events & BEV_EVENT_ERROR) {
				int err = bufferevent_socket_get_dns_error(bev);
				if (err)
					printf("DNS error: %s\n", evutil_gai_strerror(err));
			}
			client->onClose();
			event_base_loopexit(base, NULL);
		}
	};

	auto readcb = [](struct bufferevent *bev, void *ctx){
		TCPClient * client = (TCPClient*)ctx;
		std::lock_guard<std::mutex> lock{client->mutex};
		std::string data = "";
        while(true){
        	char buff[1024];
        	size_t bs = bufferevent_read(bev, buff, sizeof(buff));
        	if(bs<=0)break;
        	data += std::string(buff,bs);
        }
        client->onData(data);
	};

	bufferevent_setcb(bev, readcb, NULL, eventcb, this);
	bufferevent_enable(bev, EV_READ|EV_WRITE);
	
	struct evdns_base *dns_base = evdns_base_new(base, 1);
	bufferevent_socket_connect_hostname(bev, dns_base, AF_UNSPEC, host.c_str(), port);
	runloop = std::move(std::thread{[this](){
		event_base_dispatch(base);
		bufferevent_free(bev);
		event_free(ev_user);
		//event_base_free(base); // WTF??? Poco::MemoryPool::~MemoryPool() segfaults when this on.
	}});
}

void Susi::Api::TCPClient::send(std::string & data){
	bufferevent_write(bev,data.c_str(),data.size());
}

void Susi::Api::TCPClient::close(){
	std::lock_guard<std::mutex> lock{mutex};
	event_active(ev_user, EV_READ|EV_WRITE, 1);
	onClose();
}


void Susi::Api::TCPClient::join(){
	runloop.join();
}

Susi::Api::TCPClient::~TCPClient(){
	close();
	join();
}
